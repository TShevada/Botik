import os
import logging
import asyncio
from datetime import datetime
from aiogram import Bot, Dispatcher, types, F
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from aiohttp import web
from collections import defaultdict

# --- Configuration ---
TOKEN = os.getenv("TELEGRAM_TOKEN")  # Set in Render environment
ADMIN_ID = 1291104906  # Your Telegram ID
PORT = int(os.getenv("PORT", "10001"))  # Try 10001-10025
PAYMENT_CARD = "4169 7388 9268 3164"

# --- Setup ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.MARKDOWN))
dp = Dispatcher()

# --- Data Storage ---
user_lang = {}
user_data = {}
pending_approvals = {}
approved_tickets = defaultdict(list)

# --- Ticket Types ---
TICKET_TYPES = {
    "standard": {
        "az": {
            "name": "Standard â€” 20 AZN",
            "desc": "â€¢ QarÅŸÄ±lama kokteyllÉ™ri\nâ€¢ Fan ZonasÄ±",
            "note": "â—ï¸NÉ™zÉ™rinizÉ™ Ã§atdÄ±rÄ±rÄ±q ki, biletlÉ™r alÄ±ndÄ±qdan sonra geri qaytarÄ±lmÄ±r"
        },
        "ru": {
            "name": "Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚ â€” 20 AZN", 
            "desc": "â€¢ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ¾ĞºÑ‚ĞµĞ¹Ğ»Ğ¸\nâ€¢ Fan Zone",
            "note": "â—ï¸ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ±Ğ¸Ğ»ĞµÑ‚Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ»ĞµĞ¶Ğ°Ñ‚ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸"
        },
        "en": {
            "name": "Standard â€” 20 AZN",
            "desc": "â€¢ Welcome cocktails\nâ€¢ Fan Zone",
            "note": "â—ï¸Please note that tickets cannot be refunded after purchase"
        }
    },
    "vip_single": {
        "az": {
            "name": "VIP (FÉ™rdi) â€” 40 AZN",
            "desc": "â€¢ FÉ™rdi masa yeri\nâ€¢ QarÅŸÄ±lama kokteyli\nâ€¢ YerlÉ™rin sayÄ± mÉ™hduddur",
            "note": "â—ï¸NÉ™zÉ™rinizÉ™ Ã§atdÄ±rÄ±rÄ±q ki, biletlÉ™r alÄ±ndÄ±qdan sonra geri qaytarÄ±lmÄ±r"
        },
        "ru": {
            "name": "VIP (Ğ˜Ğ½Ğ´Ğ¸Ğ²Ğ¸Ğ´ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹) â€” 40 AZN",
            "desc": "â€¢ Ğ˜Ğ½Ğ´Ğ¸Ğ²Ğ¸Ğ´ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾\nâ€¢ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ ĞºĞ¾ĞºÑ‚ĞµĞ¹Ğ»ÑŒ\nâ€¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¼ĞµÑÑ‚ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¾",
            "note": "â—ï¸ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ±Ğ¸Ğ»ĞµÑ‚Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ»ĞµĞ¶Ğ°Ñ‚ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸"
        },
        "en": {
            "name": "VIP (Single) â€” 40 AZN", 
            "desc": "â€¢ Individual seat\nâ€¢ Welcome cocktail\nâ€¢ Limited seats available",
            "note": "â—ï¸Please note that tickets cannot be refunded after purchase"
        }
    },
    "vip_table": {
        "az": {
            "name": "VIP (Masa) â€” 160 AZN",
            "desc": "â€¢ 4 nÉ™fÉ™rlik ayrÄ±ca masa\nâ€¢ BÃ¼tÃ¼n ÅŸirkÉ™t Ã¼Ã§Ã¼n qarÅŸÄ±lama kokteyllÉ™ri\nâ€¢ YerlÉ™rin sayÄ± mÉ™hduddur",
            "note": "â—ï¸NÉ™zÉ™rinizÉ™ Ã§atdÄ±rÄ±rÄ±q ki, biletlÉ™r alÄ±ndÄ±qdan sonra geri qaytarÄ±lmÄ±r"
        },
        "ru": {
            "name": "VIP (Ğ¡Ñ‚Ğ¾Ğ»Ğ¸Ğº) â€” 160 AZN",
            "desc": "â€¢ Ğ¡Ñ‚Ğ¾Ğ»Ğ¸Ğº Ğ½Ğ° 4 Ğ¿ĞµÑ€ÑĞ¾Ğ½Ñ‹\nâ€¢ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ¾ĞºÑ‚ĞµĞ¹Ğ»Ğ¸ Ğ´Ğ»Ñ Ğ²ÑĞµĞ¹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸\nâ€¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¼ĞµÑÑ‚ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¾", 
            "note": "â—ï¸ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ±Ğ¸Ğ»ĞµÑ‚Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ»ĞµĞ¶Ğ°Ñ‚ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸"
        },
        "en": {
            "name": "VIP (Table) â€” 160 AZN",
            "desc": "â€¢ Table for 4 people\nâ€¢ Welcome cocktails for whole group\nâ€¢ Limited seats available",
            "note": "â—ï¸Please note that tickets cannot be refunded after purchase"
        }
    },
    "exclusive_table": {
        "az": {
            "name": "Exclusive (Masa) â€” 240 AZN",
            "desc": "â€¢ DJ masasÄ±nÄ±n yanÄ±nda giriÅŸ imkanÄ±\nâ€¢ 4 nÉ™fÉ™rlik ayrÄ±ca masa\nâ€¢ BÃ¼tÃ¼n ÅŸirkÉ™t Ã¼Ã§Ã¼n qarÅŸÄ±lama kokteyllÉ™ri\nâ€¢ YerlÉ™rin sayÄ± mÉ™hduddur",
            "note": "â—ï¸NÉ™zÉ™rinizÉ™ Ã§atdÄ±rÄ±rÄ±q ki, biletlÉ™r alÄ±ndÄ±qdan sonra geri qaytarÄ±lmÄ±r"
        },
        "ru": {
            "name": "Exclusive (Ğ¡Ñ‚Ğ¾Ğ»Ğ¸Ğº) â€” 240 AZN",
            "desc": "â€¢ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº DJ-Ğ·Ğ¾Ğ½Ğµ\nâ€¢ Ğ¡Ñ‚Ğ¾Ğ»Ğ¸Ğº Ğ½Ğ° 4 Ğ¿ĞµÑ€ÑĞ¾Ğ½Ñ‹\nâ€¢ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ¾ĞºÑ‚ĞµĞ¹Ğ»Ğ¸ Ğ´Ğ»Ñ Ğ²ÑĞµĞ¹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸\nâ€¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¼ĞµÑÑ‚ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¾",
            "note": "â—ï¸ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ±Ğ¸Ğ»ĞµÑ‚Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ»ĞµĞ¶Ğ°Ñ‚ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸"
        },
        "en": {
            "name": "Exclusive (Table) â€” 240 AZN",
            "desc": "â€¢ DJ area access\nâ€¢ Table for 4 people\nâ€¢ Welcome cocktails for whole group\nâ€¢ Limited seats available",
            "note": "â—ï¸Please note that tickets cannot be refunded after purchase"
        }
    }
}

# --- Web Server for Render ---
async def health_check(request):
    return web.Response(text="Bot is running")

async def run_web_server():
    app = web.Application()
    app.router.add_get("/", health_check)
    runner = web.AppRunner(app)
    await runner.setup()
    try:
        site = web.TCPSite(runner, "0.0.0.0", PORT)
        await site.start()
        logger.info(f"ğŸŒ Health check running on port {PORT}")
    except OSError as e:
        logger.error(f"Port {PORT} unavailable, trying fallback...")
        site = web.TCPSite(runner, "0.0.0.0", 10002)  # Fallback port
        await site.start()

# --- Helper Functions ---
def is_admin(user_id: int) -> bool:
    return user_id == ADMIN_ID

def get_lang_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹"), KeyboardButton(text="ğŸ‡¦ğŸ‡¿ AzÉ™rbaycan")],
            [KeyboardButton(text="ğŸ‡¬ğŸ‡§ English")]
        ],
        resize_keyboard=True
    )

def get_menu_keyboard(lang):
    if lang == "ru":
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="ğŸ« Ğ‘Ğ¸Ğ»ĞµÑ‚Ñ‹")],
                [KeyboardButton(text="ğŸ“… Ğ‘Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ")],
                [KeyboardButton(text="ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹")],
                [KeyboardButton(text="ğŸŒ Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº")]
            ],
            resize_keyboard=True
        )
    elif lang == "az":
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="ğŸ« BiletlÉ™r")],
                [KeyboardButton(text="ğŸ“… YaxÄ±n tÉ™dbirlÉ™r")],
                [KeyboardButton(text="ğŸ“ ÆlaqÉ™")],
                [KeyboardButton(text="ğŸŒ Dil dÉ™yiÅŸ")]
            ],
            resize_keyboard=True
        )
    else:  # English
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="ğŸ« Tickets")],
                [KeyboardButton(text="ğŸ“… Upcoming events")],
                [KeyboardButton(text="ğŸ“ Contacts")],
                [KeyboardButton(text="ğŸŒ Change language")]
            ],
            resize_keyboard=True
        )

def get_ticket_type_keyboard(lang):
    buttons = []
    for ticket_type in TICKET_TYPES:
        buttons.append([KeyboardButton(text=TICKET_TYPES[ticket_type][lang]["name"])])
    
    back_text = "â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´" if lang == "ru" else "â¬…ï¸ Geri" if lang == "az" else "â¬…ï¸ Back"
    buttons.append([KeyboardButton(text=back_text)])
    
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)

def get_admin_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ğŸ“‹ ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸", callback_data="admin_last_orders")],
        [InlineKeyboardButton(text="ğŸ” ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ ID", callback_data="admin_search"),
         InlineKeyboardButton(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="admin_refresh")]
    ])

# [Previous imports and configuration remain the same...]

# --- Handlers ---
@dp.message(Command("start"))
async def start_cmd(message: types.Message):
    await message.answer("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ·Ñ‹Ğº / Select language / Dil seÃ§in:", reply_markup=get_lang_keyboard())

@dp.message(F.text.in_(["ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹", "ğŸ‡¦ğŸ‡¿ AzÉ™rbaycan", "ğŸ‡¬ğŸ‡§ English"]))
async def set_language(message: types.Message):
    lang_map = {
        "ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹": "ru",
        "ğŸ‡¦ğŸ‡¿ AzÉ™rbaycan": "az",
        "ğŸ‡¬ğŸ‡§ English": "en"
    }
    user_lang[message.from_user.id] = lang_map[message.text]
    
    confirmation = {
        "ru": "Ğ¯Ğ·Ñ‹Ğº ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½: Ğ ÑƒÑÑĞºĞ¸Ğ¹",
        "az": "Dil seÃ§ildi: AzÉ™rbaycan",
        "en": "Language set: English"
    }[lang_map[message.text]]
    
    await message.answer(confirmation, reply_markup=get_menu_keyboard(lang_map[message.text]))

@dp.message(F.text.in_(["ğŸ“… Ğ‘Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ", "ğŸ“… YaxÄ±n tÉ™dbirlÉ™r", "ğŸ“… Upcoming events"]))
async def events_handler(message: types.Message):
    lang = user_lang.get(message.from_user.id, "en")
    events_info = {
        "ru": "Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¸Ğ²ĞµĞ½Ñ‚: Afro-Party Ğ² Voodoo!\n"
              "ğŸ“… Ğ”Ğ°Ñ‚Ğ°: 27 Ğ°Ğ¿Ñ€ĞµĞ»Ñ 2025\n"
              "ğŸ•’ Ğ’Ñ€ĞµĞ¼Ñ: 18:00 - 00:00\n"
              "ğŸ“ ĞœĞµÑÑ‚Ğ¾: Ğ ĞµÑÑ‚Ğ¾Ğ±Ğ°Ñ€ Voodoo, Ğ¢Ğ Ğ¦ ĞĞ°Ñ€Ğ³Ğ¸Ğ· ĞœĞ¾Ğ»Ğ», 3 ÑÑ‚Ğ°Ğ¶",
        "az": "Cari tÉ™dbir: Afro-Party Voodoo-da!\n"
              "ğŸ“… Tarix: 27 Aprel 2025\n"
              "ğŸ•’ Vaxt: 18:00 - 00:00\n"
              "ğŸ“ Yer: Voodoo Restobar, Nargiz Mall, 3-cÃ¼ mÉ™rtÉ™bÉ™",
        "en": "Current event: Afro-Party at Voodoo!\n"
              "ğŸ“… Date: April 27, 2025\n"
              "ğŸ•’ Time: 6:00 PM - 12:00 AM\n"
              "ğŸ“ Location: Voodoo Restobar, Nargiz Mall, 3rd floor"
    }[lang]
    await message.answer(events_info)

@dp.message(F.text.in_(["ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹", "ğŸ“ ÆlaqÉ™", "ğŸ“ Contacts"]))
async def contacts_handler(message: types.Message):
    lang = user_lang.get(message.from_user.id, "en")
    contact_info = {
        "ru": "ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹:\nĞ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: +994 10 531 24 06",
        "az": "ğŸ“ ÆlaqÉ™:\nTelefon: +994 10 531 24 06",
        "en": "ğŸ“ Contacts:\nPhone: +994 10 531 24 06"
    }[lang]
    await message.answer(contact_info)

@dp.message(F.text.in_(["ğŸŒ Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº", "ğŸŒ Dil dÉ™yiÅŸ", "ğŸŒ Change language"]))
async def change_lang_handler(message: types.Message):
    await message.answer(
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ·Ñ‹Ğº / Select language / Dil seÃ§in:",
        reply_markup=get_lang_keyboard()
    )

@dp.message(F.text.in_(["ğŸ« Ğ‘Ğ¸Ğ»ĞµÑ‚Ñ‹", "ğŸ« BiletlÉ™r", "ğŸ« Tickets"]))
async def tickets_menu_handler(message: types.Message):
    lang = user_lang.get(message.from_user.id, "en")
    await message.answer(
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ°:" if lang == "ru" else "Bilet nÃ¶vÃ¼nÃ¼ seÃ§in:" if lang == "az" else "Select ticket type:",
        reply_markup=get_ticket_type_keyboard(lang)
    )

@dp.message(lambda message: any(
    message.text.startswith(ticket[lang]["name"].split("â€”")[0].strip())
    for ticket in TICKET_TYPES.values()
    for lang in ["az", "ru", "en"]
))
async def ticket_type_handler(message: types.Message):
    lang = user_lang.get(message.from_user.id, "en")
    
    # Find which ticket type was selected
    ticket_type = None
    for t_type, t_data in TICKET_TYPES.items():
        if message.text.startswith(t_data[lang]["name"].split("â€”")[0].strip()):
            ticket_type = t_type
            break
    
    if not ticket_type:
        await message.answer("ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ°" if lang == "ru" else "YanlÄ±ÅŸ bilet nÃ¶vÃ¼" if lang == "az" else "Invalid ticket type")
        return
    
    user_data[message.from_user.id] = {
        "step": "name",
        "lang": lang,
        "ticket_type": ticket_type,
        "ticket_price": TICKET_TYPES[ticket_type][lang]["name"].split("â€”")[1].strip()
    }
    
    prompt = {
        "ru": "Ğ”Ğ»Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ² Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°ÑˆĞµ Ğ˜Ğ¼Ñ Ğ¸ Ğ¤Ğ°Ğ¼Ğ¸Ğ»Ğ¸Ñ:",
        "az": "Bilet almaq Ã¼Ã§Ã¼n ad vÉ™ soyadÄ±nÄ±zÄ± daxil edin:",
        "en": "To buy tickets, please enter your First and Last name:"
    }[lang]
    
    await message.answer(prompt, reply_markup=types.ReplyKeyboardRemove())

@dp.message(lambda m: user_data.get(m.from_user.id, {}).get("step") == "name")
async def get_name(message: types.Message):
    user_data[message.from_user.id]["name"] = message.text
    user_data[message.from_user.id]["step"] = "phone"
    lang = user_data[message.from_user.id].get("lang", "en")
    
    prompt = {
        "ru": "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:",
        "az": "Ä°ndi telefon nÃ¶mrÉ™nizi daxil edin:",
        "en": "Now please enter your phone number:"
    }[lang]
    
    await message.answer(prompt)

@dp.message(lambda m: user_data.get(m.from_user.id, {}).get("step") == "phone")
async def get_phone(message: types.Message):
    phone = message.text
    if not phone.replace('+', '').isdigit() or len(phone) < 9:
        lang = user_data[message.from_user.id].get("lang", "en")
        error_msg = {
            "ru": "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°",
            "az": "ZÉ™hmÉ™t olmasa, dÃ¼zgÃ¼n telefon nÃ¶mrÉ™si daxil edin",
            "en": "Please enter a valid phone number"
        }[lang]
        await message.answer(error_msg)
        return
    
    user_data[message.from_user.id]["phone"] = phone
    user_data[message.from_user.id]["step"] = "confirm"
    lang = user_data[message.from_user.id].get("lang", "en")
    
    ticket_type = user_data[message.from_user.id]["ticket_type"]
    ticket_info = TICKET_TYPES[ticket_type][lang]
    
    confirmation = {
        "ru": f"ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ²Ğ°ÑˆĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ:\n\n"
              f"ğŸŸ Ğ¢Ğ¸Ğ¿ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ°: {ticket_info['name']}\n"
              f"ğŸ’³ Ğ¡ÑƒĞ¼Ğ¼Ğ°: {ticket_info['name'].split('â€”')[1].strip()}\n"
              f"ğŸ‘¤ Ğ˜Ğ¼Ñ: {user_data[message.from_user.id]['name']}\n"
              f"ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {phone}\n\n"
              f"Ğ’ÑĞµ Ğ²ĞµÑ€Ğ½Ğ¾?",
        "az": f"MÉ™lumatlarÄ±nÄ±zÄ± yoxlayÄ±n:\n\n"
              f"ğŸŸ Bilet nÃ¶vÃ¼: {ticket_info['name']}\n"
              f"ğŸ’³ MÉ™blÉ™ÄŸ: {ticket_info['name'].split('â€”')[1].strip()}\n"
              f"ğŸ‘¤ Ad: {user_data[message.from_user.id]['name']}\n"
              f"ğŸ“± Telefon: {phone}\n\n"
              f"HÉ™r ÅŸey dÃ¼zgÃ¼ndÃ¼r?",
        "en": f"Please confirm your details:\n\n"
              f"ğŸŸ Ticket type: {ticket_info['name']}\n"
              f"ğŸ’³ Amount: {ticket_info['name'].split('â€”')[1].strip()}\n"
              f"ğŸ‘¤ Name: {user_data[message.from_user.id]['name']}\n"
              f"ğŸ“± Phone: {phone}\n\n"
              f"Is everything correct?"
    }[lang]
    
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="âœ… Ğ”Ğ°" if lang == "ru" else "âœ… BÉ™li" if lang == "az" else "âœ… Yes")],
            [KeyboardButton(text="âŒ ĞĞµÑ‚" if lang == "ru" else "âŒ Xeyr" if lang == "az" else "âŒ No")]
        ],
        resize_keyboard=True
    )
    
    await message.answer(confirmation, reply_markup=keyboard)

@dp.message(F.text.in_(["âœ… Ğ”Ğ°", "âœ… BÉ™li", "âœ… Yes"]))
async def confirm_purchase(message: types.Message):
    if message.from_user.id not in user_data:
        return
    
    lang = user_data[message.from_user.id].get("lang", "en")
    user_data[message.from_user.id]["step"] = "payment"
    
    payment_info = {
        "ru": f"ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚Ğµ {user_data[message.from_user.id]['ticket_price']} Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñƒ: `{PAYMENT_CARD}`\n"
              "Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞºÑ€Ğ¸Ğ½ÑˆĞ¾Ñ‚ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹.\n\n"
              f"{TICKET_TYPES[user_data[message.from_user.id]['ticket_type']][lang]['note']}",
        "az": f"{user_data[message.from_user.id]['ticket_price']} mÉ™blÉ™ÄŸini kartla Ã¶dÉ™yin: `{PAYMENT_CARD}`\n"
              "vÉ™ Ã¶dÉ™niÅŸ skrinÅŸotu gÃ¶ndÉ™rin.\n\n"
              f"{TICKET_TYPES[user_data[message.from_user.id]['ticket_type']][lang]['note']}",
        "en": f"Please pay {user_data[message.from_user.id]['ticket_price']} to card: `{PAYMENT_CARD}`\n"
              "and send payment screenshot.\n\n"
              f"{TICKET_TYPES[user_data[message.from_user.id]['ticket_type']][lang]['note']}"
    }[lang]
    
    await message.answer(payment_info, reply_markup=get_menu_keyboard(lang))

@dp.message(F.text.in_(["âŒ ĞĞµÑ‚", "âŒ Xeyr", "âŒ No"]))
async def cancel_purchase(message: types.Message):
    lang = user_lang.get(message.from_user.id, "en")
    if message.from_user.id in user_data:
        del user_data[message.from_user.id]
    
    msg = {
        "ru": "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½. ĞœĞ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾.",
        "az": "SifariÅŸ lÉ™ÄŸv edildi. YenidÉ™n baÅŸlaya bilÉ™rsiniz.",
        "en": "Order canceled. You can start again."
    }[lang]
    
    await message.answer(msg, reply_markup=get_menu_keyboard(lang))

@dp.message(lambda m: user_data.get(m.from_user.id, {}).get("step") == "payment")
async def handle_payment(message: types.Message):
    lang = user_data[message.from_user.id].get("lang", "en")
    
    if message.photo:
        try:
            photo = message.photo[-1]
            user_id = message.from_user.id
            data = user_data[user_id]
            
            # Store the pending approval
            pending_approvals[user_id] = {
                "name": data["name"],
                "phone": data["phone"],
                "ticket_type": data["ticket_type"],
                "ticket_price": data["ticket_price"],
                "photo_id": photo.file_id,
                "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "approved": None
            }
            
            # Notify admin
            await notify_admin(
                user_id,
                data["name"],
                data["phone"],
                data["ticket_type"],
                data["ticket_price"],
                photo.file_id
            )
            
            confirmation = {
                "ru": "Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! Ğ’Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¸Ğ¸.",
                "az": "TÉ™ÅŸÉ™kkÃ¼rlÉ™r! MÃ¼raciÉ™tiniz nÉ™zÉ™rdÉ™n keÃ§irilir.",
                "en": "Thank you! Your application is under review."
            }[lang]
            
            await message.answer(confirmation, reply_markup=get_menu_keyboard(lang))
            del user_data[message.from_user.id]
            
        except Exception as e:
            logger.error(f"Payment processing error: {e}")
            error_msg = {
                "ru": "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ½Ğ¾Ğ²Ğ°",
                "az": "Ã–dÉ™niÅŸ emalÄ± xÉ™tasÄ±, yenidÉ™n cÉ™hd edin",
                "en": "Payment processing error, please try again"
            }[lang]
            await message.answer(error_msg)
    else:
        prompt = {
            "ru": "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑĞºÑ€Ğ¸Ğ½ÑˆĞ¾Ñ‚ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹.",
            "az": "ZÉ™hmÉ™t olmasa, Ã¶dÉ™niÅŸ skrinÅŸotu gÃ¶ndÉ™rin.",
            "en": "Please send the payment screenshot."
        }[lang]
        await message.answer(prompt)

@dp.message(Command("admin"))
async def admin_command(message: types.Message):
    if not is_admin(message.from_user.id):
        await message.answer("â›” Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½!")
        return
        
    await message.answer(
        "ğŸ›  *ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°*",
        reply_markup=get_admin_keyboard(),
        parse_mode="Markdown"
    )

@dp.callback_query(F.data.startswith("admin_"))
async def handle_admin_callbacks(callback: types.CallbackQuery):
    if not is_admin(callback.from_user.id):
        await callback.answer("â›” Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½!")
        return
    
    try:
        action = callback.data.split('_')[1]
        
        if action == "last_orders":
            if not pending_approvals:
                await callback.message.edit_text("ğŸ“­ ĞĞµÑ‚ Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¸Ğ¸", reply_markup=get_admin_keyboard())
                return
                
            report = "ğŸ“‹ *ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ğ·Ğ°ÑĞ²ĞºĞ¸:*\n\n"
            for user_id, data in list(pending_approvals.items())[-5:]:
                report += (
                    f"ğŸ”¹ *ID:* {user_id}\n"
                    f"ğŸ‘¤ *{data['name']}*\n"
                    f"ğŸ“ `{data['phone']}`\n"
                    f"ğŸŸ {data['ticket_type']} ({data['ticket_price']})\n"
                    f"ğŸ•’ {data['date']}\n"
                    "â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                )
            await callback.message.edit_text(report, reply_markup=get_admin_keyboard())
            
        elif action == "search":
            await callback.message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:")
            admin_pending_actions[callback.from_user.id] = "waiting_for_id"
            
        elif action == "refresh":
            await callback.message.edit_text(
                "ğŸ›  *ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°*",
                reply_markup=get_admin_keyboard(),
                parse_mode="Markdown"
            )
            
        await callback.answer()
    except Exception as e:
        logger.error(f"Admin callback error: {e}")
        await callback.answer("âš ï¸ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°")

@dp.message(lambda m: admin_pending_actions.get(m.from_user.id) == "waiting_for_id")
async def handle_admin_search(message: types.Message):
    if not is_admin(message.from_user.id):
        return
        
    try:
        user_id = int(message.text)
        data = pending_approvals.get(user_id)
        
        if not data:
            await message.answer("âŒ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        else:
            report = (
                f"ğŸ” *ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ·Ğ°ÑĞ²ĞºĞ°:*\n\n"
                f"ğŸ‘¤ *{data['name']}*\n"
                f"ğŸ“ `{data['phone']}`\n"
                f"ğŸŸ {data['ticket_type']} ({data['ticket_price']})\n"
                f"ğŸ•’ {data['date']}\n\n"
                f"ĞÑ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° ÑÑ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹:\n"
                f"/accept - Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ\n"
                f"/reject [Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°] - Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ"
            )
            await message.answer(report, parse_mode="Markdown")
            
    except ValueError:
        await message.answer("âŒ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğ¹ ID")
    finally:
        admin_pending_actions.pop(message.from_user.id, None)

@dp.message(Command("accept"))
async def accept_request(message: types.Message):
    if not is_admin(message.from_user.id):
        return
        
    if not message.reply_to_message:
        await message.answer("â„¹ï¸ ĞÑ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ Ğ·Ğ°ÑĞ²ĞºĞ¾Ğ¹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ")
        return
        
    try:
        text = message.reply_to_message.text
        user_id = int(text.split("ID:")[1].split("\n")[0].strip())
        
        if user_id in pending_approvals:
            # Move to approved tickets
            approved_tickets[user_id] = pending_approvals[user_id]
            approved_tickets[user_id]["approved"] = True
            del pending_approvals[user_id]
            
            await message.answer(f"âœ… Ğ—Ğ°ÑĞ²ĞºĞ° {user_id} Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°")
            await bot.send_message(
                user_id,
                "ğŸ‰ Ğ’Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°! Ğ‘Ğ¸Ğ»ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½."
            )
        else:
            await message.answer("âš ï¸ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ² Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ…")
    except Exception as e:
        logger.error(f"Accept error: {e}")
        await message.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ")

@dp.message(Command("reject"))
async def reject_request(message: types.Message):
    if not is_admin(message.from_user.id):
        return
        
    if not message.reply_to_message:
        await message.answer("â„¹ï¸ ĞÑ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ Ğ·Ğ°ÑĞ²ĞºĞ¾Ğ¹ Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ")
        return
        
    try:
        text = message.reply_to_message.text
        user_id = int(text.split("ID:")[1].split("\n")[0].strip())
        reason = message.text.split("/reject")[1].strip() if len(message.text.split("/reject")) > 1 else "Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°"
        
        if user_id in pending_approvals:
            pending_approvals[user_id]["approved"] = False
            
            await message.answer(f"âŒ Ğ—Ğ°ÑĞ²ĞºĞ° {user_id} Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ°")
            await bot.send_message(
                user_id,
                f"âš ï¸ Ğ’Ğ°ÑˆĞ° Ğ·Ğ°ÑĞ²ĞºĞ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ°. ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {reason}"
            )
            del pending_approvals[user_id]
        else:
            await message.answer("âš ï¸ Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ² Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ…")
    except Exception as e:
        logger.error(f"Reject error: {e}")
        await message.answer("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ñ")

async def notify_admin(user_id: int, name: str, phone: str, ticket_type: str, ticket_price: str, photo_id: str):
    try:
        # Send photo first
        await bot.send_photo(
            ADMIN_ID,
            photo_id,
            caption=(
                f"ğŸ†• *ĞĞ¾Ğ²Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ±Ğ¸Ğ»ĞµÑ‚*\n\n"
                f"ğŸ‘¤ ID: {user_id}\n"
                f"ğŸ“› Ğ˜Ğ¼Ñ: {name}\n"
                f"ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: `{phone}`\n"
                f"ğŸ« Ğ¢Ğ¸Ğ¿: {ticket_type}\n"
                f"ğŸ’µ Ğ¡ÑƒĞ¼Ğ¼Ğ°: {ticket_price}\n"
                f"ğŸ•’ Ğ’Ñ€ĞµĞ¼Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                f"ĞÑ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° ÑÑ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹:\n"
                f"/accept - Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ\n"
                f"/reject [Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°] - Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ"
            ),
            parse_mode="Markdown"
        )
    except Exception as e:
        logger.error(f"Failed to notify admin: {e}")

@dp.message()
async def handle_unmatched_messages(message: types.Message):
    if message.from_user.id == ADMIN_ID:
        await message.answer("â„¹ï¸ Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /admin Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ¾Ğ¼")
    else:
        lang = user_lang.get(message.from_user.id, "en")
        response = {
            "ru": "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¼ĞµĞ½Ñ",
            "az": "ZÉ™hmÉ™t olmasa menyu dÃ¼ymÉ™lÉ™rindÉ™n istifadÉ™ edin",
            "en": "Please use the menu buttons"
        }[lang]
        await message.answer(response, reply_markup=get_menu_keyboard(lang))

# --- Main ---
async def main():
    await run_web_server()
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    if not TOKEN:
        raise ValueError("âŒ TELEGRAM_TOKEN not set in environment variables!")
    logging.info("Starting bot...")
    asyncio.run(main())
